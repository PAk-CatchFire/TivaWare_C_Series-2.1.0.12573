//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "homework_3.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/timer.h"
#include "inc/tm4c1294ncpdt.h"
#include "driverlib/pwm.h"
#include "driverlib/fpu.h"

//*****************************************************************************
volatile uint8_t count;
void
PortFunctionInit(void)
{
    //
    // Enable Peripheral Clocks 
    //
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOJ);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);

    //
    // Enable pin PJ0 for GPIOInput
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTJ_AHB_BASE, GPIO_PIN_0);

    //
    // Enable pin PJ1 for GPIOInput
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTJ_AHB_BASE, GPIO_PIN_1);

    //
    // Enable pin PN1 for GPIOOutput
    //
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_1);

    //
    // Enable pin PN0 for GPIOOutput
    //
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_0);
		
		//
		//Enable Pullup for PJ0 PJ1
		GPIO_PORTJ_AHB_PUR_R |= 0x03;
		
		 //
    // Enable Peripheral Clocks 

    //
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);

    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);


    //
    // Enable pin PK4 for PWM0 M0PWM6

    //
    MAP_GPIOPinConfigure(GPIO_PK4_M0PWM6);

    MAP_GPIOPinTypePWM(GPIO_PORTK_BASE, GPIO_PIN_4);

}
void
Interrupt_Init(void)
{
  IntEnable(INT_GPIOJ);  							// enable interrupt 51 in NVIC (GPIOJ)
	IntPrioritySet(INT_GPIOJ, 0x02); 		// configure GPIOJ interrupt priority as 2
	GPIO_PORTJ_AHB_IM_R |= 0x03;   		// arm interrupt on PJ0,PJ1
	GPIO_PORTJ_AHB_IS_R &= ~0x03;     // PJ0,PJ1 is edge-sensitive
  GPIO_PORTJ_AHB_IBE_R &= ~0x03;   	// PJ0,PJ1 are not both edge-triggered. 
  GPIO_PORTJ_AHB_IEV_R &= ~0x03;  // PJ0,PJ1 falling edge event
	IntMasterEnable();        		// globally enable interrupt
}
void Timer0A_Init(unsigned long period)
{   
	//
  // Enable Peripheral Clocks 
  //
  SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
  TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); 		// configure for 32-bit timer mode
  TimerLoadSet(TIMER0_BASE, TIMER_A, period -1);      //reload value
	IntPrioritySet(INT_TIMER0A, 0x00);  	 							// configure Timer0A interrupt priority as 0
  IntEnable(INT_TIMER0A);    													// enable interrupt 19 in NVIC (Timer0A)
	TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);    // arm timeout interrupt
  TimerEnable(TIMER0_BASE, TIMER_A);      						// enable timer0A
}

//interrupt handler for Timer0A

void Timer0A_Handler(void)
{
		// acknowledge flag for Timer0A timeout
		TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
	if(count>7)
	{
		count=0;
	}
	else{
				count++;
	}
	
	if(count==0)
				{
					GPIO_PORTN_DATA_R =0x00;
					//LED D1,D2 off
					
				}
				else if(count==1)
				{
					GPIO_PORTN_DATA_R =0x02;
					//LED D1 on,D2 off
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 80);
				}
				else if(count==2)
				{
					GPIO_PORTN_DATA_R =0x01;
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 800);
				}else if(count==3)
				{
					GPIO_PORTN_DATA_R =0x03;
					//LED D1,D2 on
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 60);
				}else if(count==4)
				{
					GPIO_PORTN_DATA_R =0x02;
					//LED D1 on,D2 off
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 800);
				}
				else if(count==5)
				{
					GPIO_PORTN_DATA_R =0x02;
					//LED D1 on,D2 off
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 4);
				}
				else if(count==6)
				{
					GPIO_PORTN_DATA_R =0x02;
					//LED D1 on,D2 off
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 800);
				}
				else
				{
					count=0;
					GPIO_PORTN_DATA_R= 0x00;
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_6, 40);
					//LED D1,D2 off
				}
					
	
}

//interrupt handler
void GPIOPortJ_Handler(void)
{
	
	//SW1 is pressed
	if(GPIO_PORTJ_AHB_RIS_R&0x01)
	{
		// acknowledge flag for PJ0
		GPIOIntClear(GPIO_PORTJ_AHB_BASE, GPIO_PIN_0);     
		//counter imcremented by 1
		count++;
	}
	
	//SW2 is pressed
  if(GPIO_PORTJ_AHB_RIS_R&0x02)
	{
		// acknowledge flag for PJ1
		GPIOIntClear(GPIO_PORTJ_AHB_BASE, GPIO_PIN_1);     
		//counter imcremented by 1
		count--;
	}
	if(count==0)
				{
					GPIO_PORTN_DATA_R =0x00;
					//LED D1,D2 off
				}
				else if(count==1)
				{
					GPIO_PORTN_DATA_R =0x02;
					//LED D1 off,D2 on
				}
				else if(count==2)
				{
					GPIO_PORTN_DATA_R =0x01;
					//LED D1 on ,D2 off
				}else if(count==3)
				{
					GPIO_PORTN_DATA_R =0x03;
					//LED D1,D2 on
				}else
				{
					count=0;
					GPIO_PORTN_DATA_R= 0x00;
					//LED D1,D2 off
				}
	
	
}	
int main(void)
	{			
			unsigned long period = 64000000; //reload value to Timer0A to generate a second delay
			PortFunctionInit();
			//intialize ports
			Timer0A_Init(period);
			// Load the timer with value 
			Interrupt_Init();
			PWMGenConfigure(PWM0_BASE, PWM_GEN_3,PWM_GEN_MODE_DOWN);
			PWMGenPeriodSet(PWM0_BASE, PWM_GEN_3, 800);
			PWMGenEnable(PWM0_BASE, PWM_GEN_3);
			PWMOutputState(PWM0_BASE, PWM_OUT_6_BIT , true);
			//
			//loop forever
			//
			while(1)
			{
				
				
			}
			
}
 
