//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************
#include	<stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include "pwm.h"
#include "PWM_10-30.h"
#include "inc/hw_types.h"
#include	"driverlib/fpu.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"
#include "driverlib/debug.h"
#include "driverlib/pwm.h"
#include "driverlib/pin_map.h"
#include "inc/tm4c1294ncpdt.h"
#include	"driverlib/uart.h"
#include	"driverlib/timer.h"
#include	"driverlib/interrupt.h"
//#define PWM_FREQUENCY	1000|
//#define APP_PI 3.1415926535897932384626433832795f
//#define STEPS 256
volatile uint8_t count;
//*****************************************************************************
void
PortFunctionInit(void)
{
    //
    // Enable Peripheral Clocks 
    //
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);

    //
    // Enable pin PG0 for PWM0 M0PWM4
    //
    MAP_GPIOPinConfigure(GPIO_PG0_M0PWM4);
    MAP_GPIOPinTypePWM(GPIO_PORTG_BASE, GPIO_PIN_0);

    //
    // Enable pin PG1 for PWM0 M0PWM5
    //
    MAP_GPIOPinConfigure(GPIO_PG1_M0PWM5);
    MAP_GPIOPinTypePWM(GPIO_PORTG_BASE, GPIO_PIN_1);

    //
    // Enable pin PF3 for PWM0 M0PWM3
    //
    MAP_GPIOPinConfigure(GPIO_PF3_M0PWM3);
    MAP_GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);

    //
    // Enable pin PF2 for PWM0 M0PWM2
    //
    MAP_GPIOPinConfigure(GPIO_PF2_M0PWM2);
    MAP_GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);
}

/*void move_car(int32_t i32Returnvalue, uint8_t g_pui8CC3000_Rx_Buffer[])
{
	if(i32Returnvalue==4)
	{
		if(strcmp(g_pui8CC3000_Rx_Buffer, "STOP"))
		{
								PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			// 100% duty cycle PF 2
								PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);			// 100% duty cycle
								PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
								PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);			//100% duty cycle	PF 0
		}
	}
	else if(i32Returnvalue==3)
	{
		if(strcmp(g_pui8CC3000_Rx_Buffer,"LF1"))
			{
				UARTprintf("    Looking for TCP Packets...\n");
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
			}
			else if(strcmp(g_pui8CC3000_Rx_Buffer,"LF2"))//(c==LF2)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);			//75% duty cycle	PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
			}
			else if(strcmp(g_pui8CC3000_Rx_Buffer,"LB1"))//(c==LB1)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);			//10% duty cycle PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"LB2")))//(c==LB2)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);		//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);			//10% duty cycle	PF 0
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"RF1")))//(c==RF1)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);				//10% duty cycle	PF 0		
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"RF2")))//(c==RF2)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);		//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);		//75% duty cycle	PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"RB1")))//(c==RB1)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"RB2")))//(c==RB2)
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);		//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
			}
		}
		else if(i32Returnvalue==2)
		{
			if((strcmp(g_pui8CC3000_Rx_Buffer,"F1"))) //SW1 is pressed//(count==0)	//
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);							//10% duty cycle	PF 3
			
			}
			else if((strcmp(g_pui8CC3000_Rx_Buffer,"F2")))//(count==1)	//		//sw2 is pressed
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);						//75% duty cycle	PF 3			
			}
			else if(strcmp(g_pui8CC3000_Rx_Buffer, "B1"))//(c==B1)//(count==3)								//
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 200);			//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
			}
			else if(strcmp(g_pui8CC3000_Rx_Buffer,"B2"))//(c==B2)//(count==4)		//		//sw2 is pressed
			{
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);						//100% duty cycle PF 2
				PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);						//75% duty cycle	PF 3
			}
		}
}*/

/*void Timer0A_Handler(void)
{
		// acknowledge flag for Timer0A timeout
		TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
	PWMGenConfigure(PWM0_BASE, PWM_GEN_0, PWM_GEN_MODE_DOWN);
		PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, 400);
		PWMGenConfigure(PWM0_BASE, PWM_GEN_1, PWM_GEN_MODE_DOWN);
		PWMGenPeriodSet(PWM0_BASE, PWM_GEN_1, 400);
		PWMOutputState(PWM0_BASE, PWM_OUT_0_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_2_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true);

		PWMGenEnable(PWM0_BASE, PWM_GEN_0);
		PWMGenEnable(PWM0_BASE, PWM_GEN_1);
	
							if(count>14)
									{
											count=0;
									}
							else{
											count++;
									}
						if(count==0)	//(c==F1) //SW1 is pressed
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);							//10% duty cycle	PF 3
						
						}
						else if(count==1)	//(c==F2)		//sw2 is pressed
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);						//75% duty cycle	PF 3
						
						}
						else if(count==2) 				//(c==STOP)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						// 100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);							// 100% duty cycle
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(count==3)								//(c==B1)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 200);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
						}
						else if(count==4)		//(c==B2)		//sw2 is pressed
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);						//75% duty cycle	PF 3
						}
						else if(count==5)//(c==LF1)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(count==6)//(c==LF2)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);			//75% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(count==7)//(c==LB1)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);			//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(count==8)//(c==LB2)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);		//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);			//10% duty cycle	PF 0
						}
						else if(count==9)//(c==RF1)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);				//10% duty cycle	PF 0		
						}
						else if(count==10)//(c==RF2)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);		//75% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(count==11)//(c==RB1)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(count==13)//(c==RB2)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else
						
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0

							//PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							//PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);							//10% duty cycle	PF 3
							count=0;
						}
					}
	
void Timer0A_Init(unsigned long period)
{   
	//
  // Enable Peripheral Clocks 
  //
  SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
  TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); 		// configure for 32-bit timer mode
  TimerLoadSet(TIMER0_BASE, TIMER_A, period -1);      //reload value
	IntPrioritySet(INT_TIMER0A, 0x00);  	 							// configure Timer0A interrupt priority as 0
  IntEnable(INT_TIMER0A);    													// enable interrupt 19 in NVIC (Timer0A)
	TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);    // arm timeout interrupt
  TimerEnable(TIMER0_BASE, TIMER_A);      						// enable timer0A
}*/

/*

int main(void)
	{
		//unsigned long period = 32000000; //reload value to Timer0A to generate a second delay
		//initialize the GPIO ports
		PortFunctionInit();
		PWMGenConfigure(PWM0_BASE, PWM_GEN_0, PWM_GEN_MODE_DOWN);
		PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, 400);
		PWMGenConfigure(PWM0_BASE, PWM_GEN_1, PWM_GEN_MODE_DOWN);
		PWMGenPeriodSet(PWM0_BASE, PWM_GEN_1, 400);
		PWMOutputState(PWM0_BASE, PWM_OUT_0_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_1_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_2_BIT, true);
		PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true);
		PWMGenEnable(PWM0_BASE, PWM_GEN_0);
		PWMGenEnable(PWM0_BASE, PWM_GEN_1);
		char c[4];
		//Timer0A_Init(period);
		UARTscanf("%s",c);
		while(1)
		{
								if(c='F1') //SW1 is pressed//(count==0)	//
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);							//10% duty cycle	PF 3
						
						}
						else if(c='F2')//(count==1)	//		//sw2 is pressed
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);						//75% duty cycle	PF 3
						
						}
						else if(c='STOP')//(count==2) 
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						// 100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);							// 100% duty cycle
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(c==B1)//(count==3)								//
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 200);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
						}
						else if(c==B2)//(count==4)		//		//sw2 is pressed
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);						//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);						//75% duty cycle	PF 3
						}
						else if(c==LF1)//(count==5)//
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(c==LF2)//(count==6)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);			//75% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(c==LB1)//(count==7)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);			//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);				//10% duty cycle	PF 0
						}
						else if(c==LB2)//(count==8)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);		//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 40);			//10% duty cycle	PF 0
						}
						else if(c==RF1)//(count==9)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 150);				//10% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);				//10% duty cycle	PF 0		
						}
						else if(c==RF2)//(count==10)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);		//75% duty cycle	PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(c==RB1)//(count==11)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 150);			//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else if(c==RB2)//(count==13)
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 180);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 400);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 40);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0
						}
						else
						
						{
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);		//100% duty cycle PF 2
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);		//10% duty cycle PF 3
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_1, 400);			//100% duty cycle PF 1
							PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 400);		//10% duty cycle	PF 0

							//PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 400);						//100% duty cycle PF 2
							//PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, 180);							//10% duty cycle	PF 3
							count=0;
						}
		
		}
		return 0;
	}
		
		*/
